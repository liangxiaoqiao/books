## 无连接运输：UDP
1. UDP只是做了运输协议能够做的最少工作。除了多路复用 多路分解功能以及一些清醒的差错检测外，它几乎没有对IP增加别的东西。
1. UDP从应用进程得到数据，附加上多路复用 多路分解需要的源端口号和目的端口号字段，及其他的连个小字段，然后将形成的报文段交给网络层。网络层将该运输层报文段的封装到一个IP数据报中，然后尽力地将报文段交付给接收主机。如果该报文段到达接收主机，则UDP使用目的端口号来将报文段中的数据交付给正确的应用进程。
1. 使用UDP时，在发送报文前，发送方和接收方的运输层实体之间没有进行握手，正因如此，UDP被称为无连接的。
1. 使用UDP的原因：
    1. 应用层能更好地控制要发送的数据和发送时间。
    1. 无需连接建立。（UDP不需要任何准备即可发送数据。）
    1. 无连接状态。（TCP需要在端系统中维护连接状态。）
    1. 分组首部开销小。（每个TCP报文段都有20字节的首部开销，UDP仅有8字节的开销。）

1. UDP报文段结构
1. UDP首部只有 4个字段，每个字段由两个字节构成。（2个字节 x 4个字段 x 8位 = 64bit ）
1. 前32比特 是 **源端口号 目的端口号**；接下来32比特是 **长度 检验和**；其他是 应用数据（报文）
    ```
    前边是 报文首部 后边是报文实体
    端口号是16bit，所以 源端口号 目的端口号占32bit
    长度，校验和 都是16bit
    ```
1. UDP检验和提供了差错检验功能,即检验和用于确定当UDP报文段从源到达目的时，其中比特是否发生了改变。
1. 检验和计算方法：所有16bit和进行饭吗运算，求和时遇到任何溢出被回卷。

## 可靠数据传输原理
### 自己构造可靠数据传输协议

1. 协议rdt1.0:假设底层信道是完全可信的
    ```
    发送方：初始态-》从较高层接收数据 -> 产生包含该数据的分组->分组发送到信道中

    接收方：初始态-》从底层信道接收一个分组 -> 分组中取出数据并上传到较高层
    ```
1. 协议rdt2.0：具有比特差错信道上的可靠数据传输
    ```
    计算机网络中，基于这种重传机制的可靠数据传输协议称为 自动重传请求(ARQ)协议。
    ARQ协议还需要另外三种协议来处理存在的比特差错：
    差错检测：一种机制以使接收方检测到何时出现了比特差错。（UDP使用检验和字段就是为了这个目的。）
    接收方反馈：发送方唯一途径就是让接收方提供明确的反馈信息给发送方。（类似的，rdt2.0将从接收方向发送方回送ACK与NAK分组。）
    重传：接收方收到有差错的分组时，发送方将重传该分组。
    ```
    ```
    发送方：初始态-》较高层接收数据—》产生包含数据的分组-》①接受到反馈并且是ACK-》返回初始态 等待上层
    另一种：初始态-》较高层接收数据—》产生包含数据的分组-》②接受到反馈并且是NAK-》重传最后一个分组-》并等待返回ACK或NAK -》然后选择是到①还是②

    接收方：初始态-》从底层信道接收一个分组 -> 分组中取出数据并上传到较高层 & 返回ACK或者NAK

    发送方在等待ACK或NAK的时候，不能从上层获得更多的数据，也就是说，当接收到ACK并离开该状态时接收方才能继续获取数据。因策，发送方将不会发送一块新数据，知道发送方确信接收方已正确接收分组为止。这种行为的协议被称为 停等(stop-and-wait) 协议。
    ```
1. 协议rdt2.1 增加分组序号处理受ACK或NAK
1. 协议rdt3.0 倒计数定时器处理丢包

流水线可靠数据传输协议
```
因为发送方向接收方传输的众多分组可以被看成是填充到一条流水线中，故这种技术被称为流水线(pipelining)。

流水线对可靠数据传输协议带来的影响：
必须增加序号范围。
协议的发送方和接收方也许必须缓存多个分组。
所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、穗槐以及过度延时分组的方式
```
1. 解决流水线的差错回复有两种基本方法：回退N步  选择重传。
1. 回退N步
    ```
    暂未整理
    ```
1. 选择重传
    ```
    暂未整理
    ```
### 面向连接的运输：TCP
1. TCP是面向连接的
    ```
    这是因为在一个应用集成可以开始向另一个应用进程发送数据之前，这两个进程必须相互“握手”，即它们必须相互发送某些预备报文段，以建立确保数据传所需的参数。作为TCP连接建立的一部分，连接的双方都将初始化与TCP连接相关的许多TCP状态变量。
    ```
1. TCP连接状态完全保留在两个端系统中，所以中间要素不会维持TCP连接状态。