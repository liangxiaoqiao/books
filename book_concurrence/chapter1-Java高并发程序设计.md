### 1.走入并行的世界
1. 同步和异步
2. 并发（Concurrency）和并行（Parallelism）
    ```
    并发偏重于多个任务交替执行，多个任务之间有可能还是串行的
    并行是真正意义上的同时执行
    ```
3. 临界区
 ```
临界区用来表示一种公共资源或者说是共享数据，可以被多个线程使用。
但是每一次，只能有一个线程使用它。
```
4. 阻塞 和 非阻塞
```
阻塞和非阻塞通常用来形容多线程间的相互影响。
```
5. 死锁 饥饿和活锁
```

```
6. 并发级别
```
由于临界区的存在，多线程之间的并发必须受到控制。
根据控制并发的策略，我们可以将并发的级别进行分类。
大致上可以分为：阻塞，无饥饿，无障碍，无锁，无等待几种。

```
7. 有关并行的两个重要定律
```
Amdahl定律 定义了串行系统并行化后的加速比的计算公式和理论上限
加速比 = 优化前系统耗时/优化后系统耗时
Tn = T1（F+ 1/n(1-F)）
T1/Tn = 1/(F+1/n(1-F))
n表示处理器个数，T表示时间，F是程序中只能串行执行的比例
如果CPU处理器的数量趋于无穷，那么加速比与系统的串行化率成反比。

Gustafson定律
a+b/a+nb = n - F(n-1)
如果串行化比例很小，并行化比例很大，那么加速比就是处理器的个数。

```
8. Java内存模型（JMM）
```
原子性
可见性
有序性
```

### 2. Java并行程序基础
1. 线程的基本状态
2. 线程的基本操作 
    1. 新建
    2. 终止
    3. 线程中断
    4. 等待（wait）和通知（notify）
        wait()方法会释放目标对象的锁。sleep()不会释放任何资源。
    5. 挂起（suspend）和继续执行（resume）线程(**不提倡使用**)
        ```
        suspend()在挂起线程的同时，不会释放锁资源。
        直到对应的线程上执行了resume()方法，被挂起的线程才能继续执行。
        被挂起的线程还是Runnable。
        ```
    6. 等待线程结束(join)和谦让(yield)
        join()本质上是调用线程wait()在当前线程对象实例上
        当线程执行完成后，被等待的线程会在退出前调用notifyAll()通知所有的等待线程继续执行
        因此：不要在应用程序中，在Thread对象实例上使用wait()或notify()等方法，这很可能会印象系统API的工作，或被系统API影响
    7. volatile与Java内存模型(JMM)
        ```
        volatile只是保证了线程的可见性，并不能保证多个线程对其进行修改
        ```
    8. 线程组 守护线程 线程优先级
    9. 线程安全和synchronized
        ```
        指定加锁对象
        普通方法加synchronized，直接作用于实例方法
        静态方法加synchronized，直接作用于类方法
        ```
    10. 无提示的错误：并发下的ArraLIst HashMap
        ```
        ArrayList:size不正确，同步状态不正确，ArrayOutOfBonds
        HashMap:size不正确，循环引用
        ```


### 3. JDK并发包
1. ReentrantLock 重入锁
```
中断响应
锁申请等待限时
公平锁
```
2. Condition条件
```
```
3. Semaphore 信号量
```
```
4. ReadWriteLock
```
```
5. CountDownLatch
```
```
6. 